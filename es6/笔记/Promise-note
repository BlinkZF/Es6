深入剖析js执行机制:
浏览器常驻线程：
    js引擎线程--解释执行js代码，用户输入，网络请求
    GUI线程--绘制用户界面，与js主线程是互斥的(js可以操作dom元素,进而会影响到Gui的渲染结果，因此js引擎线程与GUI渲染线程是互斥的
    也就是说当js引擎线程处于运行状态时，GUI渲染线程将处于冻结状态)
    异步线程：
    http网络请求线程---处理用户的get、post等请求，等返回结果后将回调函数推入任务队列中
    定时触发器线程---setTimeout、setInterval等待时间结束后把执行函数推入任务队列)
    浏览器时间处理线程---将click、mouse等交互时间发生后将这些事件放入事件队列中

JS执行机制：JavaScript是单线程运行的，同时又是可以异步执行的，一般来说这种既是单线程有事异步的语言都是基于事件来驱动的
    同步和异步任务分别进入不同的执行场所，同步任务进入主线程，异步任务进入Event Table并注册函数
    但制定的事情完成之后，Event Table会将这个函数移入Event Queue
    主线程内的任务执行完毕为空，回去Event Queue读取对应的函数，进入主线程执行
    上述的过程会不断的重复，也就是常说的Event loop(事件循环) 

同步任务：
    0：代码没有执行的时候，执行栈为空栈
    1：foo函数执行的时候，创建了一帧，这帧中包含了形参，局部变量(预编译过程)然后把这一帧压入栈中        ``1 
    2：然后执行foo函数内代码
    3：创建新帧，同样有形参，局部变量，压入栈中
    4：bar函数执行完毕，弹出栈
    5：foo函数执行完毕，弹出栈
    6：执行栈为空
    执行栈其实相当于主线程
    function foo(ot){
        function bar (it){
            console.log(it);
        }
        bar(20)
        console.log(ot)
    }
    foo

异步任务：
    ajax进入Event Table，注册回调函数success
    执行console.log('run')
    ajax事件完成http网络请求线程吧任务放入Event Queue中
    主线程(调用栈)读取任务下执行success函数
    ajax({})
    console.log(run)

重新理解定时器：
    setTimeout的等待时间结束后并不是直接执行的，而是先推入浏览器的一个任务队列，在同步队列结束后再依次调用任务队列中的任务
    setTimeout(function(){},0)js主线程中的执行栈为空时，0毫秒实际上也打不到的，更具HTML标准，最低是4毫秒
    setInterval是每隔一段时间吧任务放到Event Queue之中
    定时器底层使用红黑数来写的，加上js的机制，所以不准


Promise中的异步编程是从jQuery中的deferred中演变过来的
 常见的异步操作：定时器，事件，ajax等，node中文件的读取，事件等。有一步操作就少不了回调机制
 异步编程的问题：
    产生回调地狱 难于维护和扩展
    try catch只能捕获同步代码中出现的异常,异步执行的捕获不到
    同步并发的异步存在一定的问题

es6 Promise可以解决回调地狱，以及同步并发的异步问题(异步操
但是依旧会有明显的回调痕迹，es6中的generator，es7的async await会让异步代码看起来和同步一样，写起来更加优雅

回调本质：当做某个条件满足一定条件之后，再做另外一件事 
Jquery:
    callbacks可管理回调
loadsh：JavaScript实用工具库，提供各种方法提升开发效率，提供after高阶函数辅助回调操作

高阶函数：函数参数中有函数，函数返回值是函数

Promise 原理
发布订阅模式

捕获异常的方法:
    1：catch:最推荐的方法,能用catch就用catch
    2：在Promise中通过.then的方式捕获
    3:在Promise中执行成功的语句，在.then语句中抛出一个错误。通过链式调用下一个then可以捕获错误，并且在上面的then中有
    一个错误，下面的多个then中只要有一个错误回调函数(reason) 就能捕获错误
    在多个then后面执行catch，如果then中没有写捕获异常的回调函数(reason),catch也是可以直接捕获异常的
    同样在catch后面如果写then  也是可以直接执行的
    终结：finally 用在链式调用的最后

    链式调用的时候，如果写一个空then，不会耽误后面的执行，也就是说空then相当于不存在,可以忽视


Promise.all():
    可以将多个promise实例包装成一个新的promise实例,同时成功和失败返回值是不同的
    成功的时候返回的是一个结果数组，而失败的时候返回最先被reject(排斥)失败状态的值

Promise.rece(1,2,3)里面的那个结果获得的快，就返回那个结果。不管结果本身是成功状态太还是失败状态






