ES6d的优点：es6中引入的新的语言特性，更具规范性，易读性，方便操作，简化了大型项目开发的复杂程度，降低了出错概率，提高了开发效率
语言降级工具：Babel，两种使用方法，一种是在babel官网，或者在npm本地安装。
npm init -y
npm install @babel/core 这个模块的功能主要是将某个文件中js变成成员语法树
npm install @babel/preset-env 插件集合，功能是将写的es6的语法全部转成es5
npm install @babel/cli 通过命令行对js代码进行换码
npx babel letconst.js -o new-letconst.js --watch 这里的这个watch可加可不加，加上之后会实时监控
注意：命名不要使用特殊符号
学习建议：对比性学习，考虑以前的语法有什么不同，探究下es6中的新特性是怎样实现的。

ES6：let&const
ES5: 两种作用域：全局作用域，局部作用域(函数作用域)
var:变量声明的特点：变量声明提升，可重复定义，全局变量挂载到window上
let: 变量声明的特点： 变量声明不能提升，不能重复定义，全局变量不会挂载到window上，加强了对作用域的控制
let {} =>产生块级作用域,(注意 在es5中单独使用{}是不会产生块级作用域的，只有在函数，for...等不单独使用过的时候才会产生块级作用域)
但是这又有一点和es5是一样的，就是内部可以使用外部的变量
临时死区：举个例子↓
    let a = 10;
    { 
        console.log(a); // undefined
        let a = 10
    }
这里的虽然外面有a，当执行到输出的这句代码的时候依然会报错，这个就是临时性死区的表现，
在代码执行的过程中，先会通篇扫描一下，然后就会知道，在这个块级作用域中有声明a的这一句，但是在输出的时候a还没有定义。
只有当执行到声明a这段代码之后，a才能被正常使用，在let a 之前不能使用而且也不能去外面找其他的a
let同时可以解决闭包问题。

const和let基本一样，唯一一点不同的是通过const来声明常量的。
const声明的时候，必须同时初始化。因为const一旦声明之后，值是不能改变的。
在const和let之间选择的时候，优先使用const，然后使用let，const出bug的几率会小一些，因为他的值一旦定义之后就不改变，这样的话可能效率也比较高
存储常量的空间里面的值不能发生改变
这里的空间有两个，一个是PI，一个是PI.name PI这个空间是不能发生变化的，但是PI.name这个空间内的值时可以发生变化的
const PI = {}
PI.name = 30;
console.log(PI.name)

最后总结一下：
当在使用的时候，尽量使用const(首选)/let，舍弃es5中的var
如果要使用var，整个项目都用var，不要var和let混用，对后期维护好一些

es6中的扩展运算符(spreed&rest)
...展开和收集运算符:
    此运算符在不同的地方使用有不同的功效，可以从写和读两个角度考虑
    写：function test(...arg){}; test(1,2,3);--收集作用
    注意：这个里的...arg运算符 可以将形参直接转化成数组类型
作用：简化书写长度，提升开发效率
es6/es7：es6可以处理数组，es7可以处理对象

解构(destructuring)也称结构化赋值
    解构的过程中具备两个功能，赋值和变量声明
    目的在于把等于号两边长的相似的东西内部取出来。
    对象数组都可以参见解构：
        let obj = {name：'zhangfan',age = 18};
        let {name,age} = obj;
        let name,age;({name,age} = obj)};
    作用：简化书写长度,提高开发效率
    默认参数:let {name,age,sex = 'male'} = obj; 当解构的时候没有传值则使用默认值，当传值的时候则使用传的值



箭头函数
作用优点：函数目的指向性更强，可读性更好，简化代码。提升开发效率
但是es5之前的函数，既可以当函数使用，也可以创建对象，但是箭头函数的作用只能用来当普通函数使用

箭头函数的特定
    不用写function关键字
    只能作为函数，不能new，没有原型
    参数不能重复命名
    返回值可以不写return  但是有时需要配合{}
    内部arguments this由定义时外围最接近一层的非箭头函数的arguments和this决定其值


es5-Object.defineProperty
这个方法会直接在一个对象上定义一个新的 具有详细描述的属性，或者修改一个对象的现有属性，并返回这个对象
使用：
    Object.defineProperty(对象，属性，描述符);
    描述符对，对象的属性的进行详细描述:
        数据描述符:
                value:'xxx' 属性值。默认
                writable:true 是否可写。默认false
                configurable:true 是否可配置，默认false
                enumerable：true 是否可枚举，默认false
        存取描述符:
            set:function(){}属性访问器 进行写操作时调用该方法
            get:function(){}属性访问器 进行读操作时调用该方法

注意事项：在描述符中value，writable和set，get这两组是不能同时出现的，同时出现会出现异常
作用：双向数据绑定的核心方法，主要做数据劫持操作(监控属性变化) 同时是后期es6语法中很多语法糖的底层实现的核心方法

数据劫持：
vue双向数据绑定核心功能有Observer，compile，watcher三部分实现，其中Pbserver部分功能实现由object.defineProperty实现
Observer：监测数据变化进行相应的回调(数据劫持);监测数据的变化，然后展示到视图中

Proxy&Reflect
这两种是前端发展过程中新增的东西，所以没有办法使用babel将其转化

简介:植入代理模式思想,以简介易懂的方式控制对外部对象的访问
总结:利用内置的set get方法，控制属性的读写功能用处较大，其余has deleProperty...等方法不太在工作开发中使用。有兴趣可以了解一下，
缺点：兼容性不好

Proxy(代理)：以简洁易懂的方式控制外部对对象的访问，之前用的方法是object.defineProperty+set+get进行控制的


class(构造函数)
面向对象思想简介：面向过程的目的在于把功能拆分成步骤，一环扣一环的完成，但是需求复杂到一定程度之后，对开发者的开发能力的挑战也是越来越强
面向对象的目的在于前期把功能拆分并抽象成不同的对象，聚焦于每个对象的能力和他们之间的配合，项目复杂后相对于面向过程来讲较为轻松一些
面向对象的编程语言需要具备封装，继承 多态，js不是面向对象的语言，而是基于对象的语言，js中基本上一切皆对象
面向对象的优点是：代码的复用率很高， 相对发杂业务为了做到功能复用， 降低项目的复杂度，

es6变化class

es7变化-class提案属性(浏览器不支持，可以使用babel来操作语言降级)
新特性：
    static property = xxx；静态属性
    property = xxx；私有属性
    @decorator 装饰器