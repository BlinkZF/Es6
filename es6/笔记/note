ES6d的优点：es6中引入的新的语言特性，更具规范性，易读性，方便操作，简化了大型项目开发的复杂程度，降低了出错概率，提高了开发效率
语言降级工具：Babel，两种使用方法，一种是在babel官网，或者在npm本地安装。
npm init -y
npm install @babel/core 这个模块的功能主要是将某个文件中js变成成员语法树
npm install @babel/preset-env 插件集合，功能是将写的es6的语法全部转成es5
npm install @babel/cli 通过命令行对js代码进行换码
npx babel letconst.js -o new-letconst.js --watch 这里的这个watch可加可不加，加上之后会实时监控
注意：命名不要使用特殊符号
学习建议：对比性学习，考虑以前的语法有什么不同，探究下es6中的新特性是怎样实现的。

ES6：let&const
ES5: 两种作用域：全局作用域，局部作用域(函数作用域)
var:变量声明的特点：变量声明提升，可重复定义，全局变量挂载到window上
let: 变量声明的特点： 变量声明不能提升，不能重复定义，全局变量不会挂载到window上，加强了对作用域的控制
let {} =>产生块级作用域,(注意 在es5中单独使用{}是不会产生块级作用域的，只有在函数，for...等不单独使用过的时候才会产生块级作用域)
但是这又有一点和es是一样的，就是内部可以使用外部的变量
临时死区：举个例子↓
    let a = 10;
    { 
        console.log(a);
        let a = 10
    }
这里的虽然外面有a，当执行到输出的这句代码的时候依然会报错，这个就是临时性死区的表现，
在代码执行的过程中，先会通篇扫描一下，然后就会知道，在这个块级作用域中有声明a的这一句，但是在输出的时候a还没有定义。
只有当执行到声明a这段代码之后，a才能被正常使用，在let a 之前不能使用而且也不能去外面找其他的a
let同时可以解决闭包问题。

const和let基本一样，唯一一点不同的是通过const来声明常量的。
const声明的时候，必须同时初始化。因为const一旦声明之后，值是不能改变的。
在const和let之间选择的时候，优先使用const，然后使用let，const出bug的几率会小一些，因为他的值一点定义之后就不改变，这样的话可能效率也比较高
存储常量的空间里面的值不能发生改变
这里的空间有两个，一个是PI，一个是PI.name PI这个空间是不能发生变化的，但是PI.name这个空间内的值时可以发生变化的
const PI = {}
PI.name = 30;
console.log(PI.name)

最后总结一下：
当在使用的时候，尽量使用const(首选)/let，舍弃es5中的var
如果要使用var，整个项目都用var，不要var和let混用，对后期维护好一些

es6中的扩展运算符(spreed&rest)
...展开和收集运算符:
    此运算符在不同的地方使用有不同的功效，可以从写和读两个角度考虑
    写：function test(...arg){}; test(1,2,3);--收集作用
    注意：这个里的...arg运算符 可以将形参直接转化成数组类型
作用：简化书写长度，提升开发效率
es6/es7：es6可以处理数组，es7可以处理对象

解构(destructuring)也称结构化赋值
    解构的过程中具备两个功能，赋值和变量声明
    目的在于把等于号两边长的相似的东西内部取出来。
    对象数组都可以参见解构：
        let obj = {name：'zhangfan',age = 18};
        let {name,age} = obj;
        let name,age;({name:,age} = obj)};
    作用：简化书写长度,提高开发效率
    默认参数:let {name,age,sex = 'male'} = obj;



箭头函数
作用优点：函数目的指向性更强，可读性更好，简化代码。提升开发效率
但是es5之前的函数，既可以当函数使用，有可以创建对象，但是箭头函数的作用只能用来当普通函数使用

箭头函数的特定
    不用写function关键字
    只能作为函数，不能new，没有原型
    参数不能重复命名
    返回值可以不写return  但是有时需要配合{}
    内部arguments this由定义时外围最接近一层的费箭头函数的arguments和this决定其值


